// *****************************************************************************************
// 
// templates/operations.*.hbs
//
// *****************************************************************************************
{{#each model.encodes.endPoints}}
  {{#each operations}}
/**
*
* TODO DAVE: Rewrite this for dotnet
*
{{{formatForTsDoc description}}}
*
* @param options - An object containing the options for this method.
*
* @param parameters - An object containing the parameters for this method.
{{#each ../parameters }}
*     PATH @param {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
{{/each}}
{{#each request/queryParameters}}
*     QUERY @param {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
{{/each}}
*
* @param headers - An object literal of key value pairs of the headers to be sent with this request.
{{#each request/headers}}
*     HEADER {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
{{/each}}
{{#or (is method "patch") (is method "post") (is method "put")}}
*
* @param body - The data to send as the request body.
*      BODY {{getPayloadTypeFromRequest request}}
*      MEDIA TYPE {{getMediaTypeFromRequest request}}
{{/or}}
*
* @param rawResponse - Set to true to return entire Response object instead of DTO.
*
* @returns 
*       Promise<Response> if rawResponse is true
*       Promise<{{getReturnTypeFromOperation this}}> otherwise.
* {{#if (eq (lowercase @root.metadata.categories.[CC Version Status].[0]) "beta")}}
* @beta
* {{/if}}
*/

public class {{name}}Parameters
{
    {{!-- PATH parameters --}}
    {{#each ../parameters }}
    {{#if @first}}// PATH parameters{{/if}}
    {{!-- {{#if (getValue description)}}{{{getValue description}}}{{/if}} --}}
    public required string {{{getValueCSharp name}}} { get; set; }
    {{/each}}
    {{!-- QUERY parameters --}}
    {{#each request.queryParameters}}
    {{#if @first}}

    // QUERY parameters
    {{/if}}
    public {{#if (is required "true")}}required string{{else}}string?{{/if}} {{{getValueCSharp name}}} { get; set; }
    {{#if @last}}
    public Dictionary<string, string>? Custom { get; set; }
    {{/if}}
    {{/each}}
    {{!-- HEADER parameters --}}
    {{#each request.headers}}
    {{#if @first}}
    
    // HEADER parameters{{/if}}
    {{!-- {{#if (getValue description)}}{{{getValue description}}}{{/if}} --}}
    public string? {{{name}}} { get; set; }
    {{/each}}
    {{!-- BODY parameter --}}
    {{#or (is method "patch") (is method "post") (is method "put")}}

    // BODY parameter
    public required {{getPayloadTypeFromRequest request}} Body { get; set; }
    {{/or}}
}

{{!-- public async Task<{{#if (equalsCSharp (getReturnTypeFromOperation this) 'void')}}Response{{else}}{{getReturnTypeFromOperation this}}{{/if}}> {{name}}DumDum({{name}}Parameters options, bool? rawResponse = null) --}}
{{#if (equalsCSharp (getReturnTypeFromOperation this) 'void')}}
public async Task<Response> {{name}}DumDum({{name}}Parameters options, bool? rawResponse = null)
{{else}}
public async Task<{{getReturnTypeFromOperation this}}> {{name}}DumDum({{name}}Parameters options, bool? rawResponse = null)
{{/if}}
{
    var request = new HttpRequestMessage();
    request.Method = HttpMethod.{{getValueCSharp method}};

    {{!-- (1) PATH parameters --}}
    //
    // URI PATH parameters
    //
    var uriBuilder = new UriBuilder();
    var pathTemplate = "{{../path}}";
{{#each ../parameters }}
{{#if @first}}
    var pathReplacements = new Dictionary<string, string>
    {
    {{/if}}
        { "{{{name}}}", options.{{{getValueCSharp name}}} }{{#unless @last}},{{/unless}}
    {{#if @first}}
    };
{{/if}}
{{/each}}
    uriBuilder.Path = Regex.Replace(pathTemplate, "{(.*?)}", m => pathReplacements[m.Groups[1].Value]);
    {{!-- (2) QUERY parameters --}}
{{#each request.queryParameters}}
{{#if @first}}
    //
    // URI QUERY parameters
    //
    var query = HttpUtility.ParseQueryString(uriBuilder.Query);
{{/if}}
    query["{{{name}}}"] = options.{{{getValueCSharp name}}};
{{#if @last}}
    if (options.Custom != null)
    {
        foreach (var pair in options.Custom)
        {
            query[pair.Key] = pair.Value;
        }
    }
    uriBuilder.Query = query.ToString();
{{/if}}
{{/each}}
    request.RequestUri = uriBuilder.Uri;
    {{!-- (3) HEADER parameters --}}
{{#each request.headers}}
{{#if @first}}    
    //
    // HEADER parameters
    //
{{/if}}
    {{!-- {{#if (getValue description)}}{{{getValue description}}}{{/if}} --}}
    request.Headers.{{{name}}} = new AuthenticationHeaderValue("TODO: Bearer or Basic???", options.{{{name}}});
    // additionalHeaders[USER_AGENT_HEADER] = USER_AGENT_VALUE;
    // additionalHeaders["Content-Type"] = "application/x-www-form-urlencoded";
{{/each}}
    {{!-- (4) BODY parameter --}}
{{#or (is method "patch") (is method "post") (is method "put")}}
    //
    // BODY parameter
    //
    {{!-- *      MEDIA TYPE {{getMediaTypeFromRequest request}} --}}
{{#if (eq (getMediaTypeFromRequest request) "application/json")}}
    request.Content = new StringContent(JsonConvert.SerializeObject(options.Body), Encoding.UTF8, MediaTypeNames.Application.Json);
{{else if (eq (getMediaTypeFromRequest request)  "application/x-www-form-urlencoded")}}
    var keyValues = new List<KeyValuePair<string, string>>();
    foreach (var prop in typeof({{getPayloadTypeFromRequest request}}).GetProperties())
    {
        if (prop.GetValue(options.Body, null) != null)
        {
            keyValues.Add(new KeyValuePair<string, string>(prop.Name, prop.GetValue(options.Body, null).ToString()));
        }
    }
    request.Content = new FormUrlEncodedContent(keyValues);
{{else}}
    throw new Exception("Unsupported media type: {{getMediaTypeFromRequest request}}");
{{/if}}
{{/or}}

    // TODO
    return await Task.FromResult(new Response());
}


public async Task<{{#if (equalsCSharp (getReturnTypeFromOperation this) 'void')}}Response{{else}}{{getReturnTypeFromOperation this}}{{/if}}> {{name}}(Options options, bool? rawResponse = null)
{
    var optionParams = options.Parameters;
    var configParams = ClientConfig.Parameters;

    //
    // Path parameters
    //
    Dictionary<string, string> pathParams = new Dictionary<string, string>();

    {{#each ../parameters}}
    if (optionParams != null && !string.IsNullOrEmpty(optionParams.{{{getValueCSharp name}}}))
    {
        pathParams["{{{name}}}"] = optionParams.{{{getValueCSharp name}}};
    }
    {{! if it is a common path parameter, fallback to client config for undefined }}
    {{#if (isCommonPathParameter name)}} 
    else if (configParams != null && !string.IsNullOrEmpty(configParams.{{{getValueCSharp name}}}))
    {
        pathParams["{{{name}}}"] = configParams.{{{getValueCSharp name}}};
    } 
    {{/if}}
    {{/each}}     

    //
    // Query parameters - Standard
    //
    Dictionary<string, object> queryParams = new Dictionary<string, object>();
    
    if (optionParams != null && optionParams.AdditionalProperties != null)
    {
    {{#each request.queryParameters}}
        if (optionParams.AdditionalProperties.TryGetValue("{{{name}}}", out string? {{{getValueCSharp name}}}Value))
        {
            queryParams["{{{name}}}"] = {{{getValueCSharp name}}}Value;
        }
    {{! if it is a common query parameter, fallback to client config for undefined }}
    {{#if (isCommonQueryParameter name)}} 
        else if (configParams != null && !string.IsNullOrEmpty(configParams.{{{getValueCSharp name}}}))
        {
            queryParams["{{{name}}}"] = configParams.{{{getValueCSharp name}}};
        }
    {{/if}}
    {{#if (is required "true")}}
        else
        {
            throw new Exception("Missing required query parameter: {{{name}}}");
        }
    {{/if}}
    {{#unless @last}}

    {{/unless}}
    {{/each}}
    }
    
    //
    // Query parameters - Custom
    //
    if (optionParams != null && optionParams.AdditionalProperties != null)
    {
        foreach (var entry in optionParams.AdditionalProperties)
        {
            if (entry.Key.StartsWith("c_") && entry.Value != null)
            {
                queryParams[entry.Key] = entry.Value;
            }
            else if (!queryParams.ContainsKey(entry.Key) && !pathParams.ContainsKey(entry.Key))
            {
                Console.WriteLine($"Invalid Parameter: {entry.Key}");
            }
        }
    }
    
    //
    // Headers
    //
    var baseHeaders = FetchHelper.GetHeaders(options);
    var additionalHeaders = new Dictionary<string, string>();
    additionalHeaders[USER_AGENT_HEADER] = USER_AGENT_VALUE;
    {{#if (isRequestWithPayload request)}}
    additionalHeaders["Content-Type"] = "{{{getMediaTypeFromRequest request}}}";
    {{/if}}
    var mergedHeaders = FetchHelper.MergeHeaders([baseHeaders.Headers, additionalHeaders]);        

    // DAVE TODO - THE ORIGINAL SF IDEA IS A MESS

    var fetchOptionsInit = new SdkFetchOptions{
        Client = this,
        RawResponse = rawResponse,
        Path = "{{../path}}",
        PathParameters = new PathParameters(pathParams),
        QueryParameters = new QueryParameters(queryParams),
        Headers = mergedHeaders{{#or (is method "patch") (is method "post") (is method "put")}}, 
        // Body = options.Body{{/or}},
        // FetchOptions = options.FetchOptions
    };

    {{#or (is method "patch") (is method "post") (is method "put")}}
    var fetchOptionsFinal = new SdkFetchOptionsWithBody(fetchOptionsInit) {};
    {{else}}
    var fetchOptionsFinal = new SdkFetchOptionsNoBody(fetchOptionsInit) {};
    {{/or}}

    return await FetchHelper.{{getValueCSharp method}}(fetchOptionsFinal);
}

  {{/each}}
{{/each}}
